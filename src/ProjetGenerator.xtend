/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.projet.AFFECT
import org.xtext.example.projet.COMMAND
import org.xtext.example.projet.COMMANDS
import org.xtext.example.projet.DEFINITION
import org.xtext.example.projet.EXPRESSION
import org.xtext.example.projet.FOREACH
import org.xtext.example.projet.FOR_LOOP
import org.xtext.example.projet.FUNCTION
import org.xtext.example.projet.IF_THEN
import org.xtext.example.projet.INPUTS
import org.xtext.example.projet.NOP
import org.xtext.example.projet.OUTPUTS
import org.xtext.example.projet.PROGRAM
import org.xtext.example.projet.WHILE

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ProjetGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		// Pour toutes les fonctions du fichier
		for (f : resource.allContents.toIterable.filter(typeof(FUNCTION))) {
			// On génère un fichier pour chaque fonction présente dans le fichier
			fsa.generateFile(
				"components/" + f.name + ".whp",
				f.compile
			)
		}

		// Pour chaque fichier
		for (d : resource.allContents.toIterable.filter(typeof(PROGRAM))) {
			// On génère un nouveau fichier en appliquant la fonction compile sur tous les éléments du fichier
			fsa.generateFile(
				"file.whp",
				d.compile
			)
		}
	}

	// Pour le type "Domainmodel", qui représente tout le fichier
	def compile(PROGRAM d) {
		// On compile toutes les fonctions comprises dans le fichier une à une
		'''
			«FOR f : d.functions»
				«f.compile»
				
			«ENDFOR»
		'''
	}

	// Pour le type "FUNCTION"
	def compile(FUNCTION f) {
		// On affiche le commentaire ";Result of pretty printing process function" 
		// et le nom de la fonction, puis on compile le contenu de la fonction
		'''
			; Result of pretty printing process
			function «f.name» :
			
				«f.def.compile»
		'''
	// f.def.compile est écrit après une tabulation, ce qui va indenter tout le
	// contenu de la fonction
	}

	// Pour le type "DEFINTION"
	def compile(DEFINITION d) {
		// on affiche read input, puis le code intérieur indenté, puis write output
		'''
			read «d.inputs.compile»
			%
				«d.code.compile»
			%
			write «d.outputs.compile»
		'''
	}

	// Pour le type INPUT
	def compile(INPUTS i) {
		// Rien de particulier pour l'instant
		'''
			«i.input»
		'''
	}

	// Pour le type OUTPUT
	def compile(OUTPUTS o) {
		// Rien de particulier pour l'instant
		'''
			«o.output»
		'''
	}

	// Pour le type "COMMANDS"
	def compile(COMMANDS c) {
		// Pour les commandes (IF/NOP/AFFECT/FOR/WHILE/EACH)
		'''
			«c.command.compile»«IF !c.commands.empty»;«ENDIF»
			«FOR line : c.commands»
				«line.compile»«IF line != c.commands.last»;«ENDIF»
			«ENDFOR»
		'''
	}

	// Pour le type "COMMAND", càd chaque commande 
	def compile(COMMAND c) {
		// Pour chaque commande, on caste dans le subtype pour le compiler
		if(c.eClass.name == "AFFECT"){
			return '''«(c as AFFECT).compile»'''
		}
		if(c.eClass.name == "IF_THEN"){
			return '''«(c as IF_THEN).compile»'''
		}
		if(c.eClass.name == "NOP"){
			return '''«(c as NOP).compile»'''
		}
		if(c.eClass.name == "FOR_LOOP"){
			return '''«(c as FOR_LOOP).compile»'''
		}
		if(c.eClass.name == "WHILE"){
			return '''«(c as WHILE).compile»'''
		}
		if(c.eClass.name == "FOREACH"){
			return '''«(c as FOREACH).compile»'''
		}
	}

	// Pour le type "AFFECT"
	def compile(AFFECT a) {
		'''«a.variable» := «a.valeur»'''
	}

	// Pour le type "IF_THEN"
	def compile(IF_THEN if_then) {
		// TODO
		'''
			if «if_then.cond.compile» then
				«FOR line : if_then.commands1»
					«line.compile»
				«ENDFOR»
			«IF !if_then.commands2.empty»
			else
				«FOR line : if_then.commands2»
					«line.compile»
				«ENDFOR»
			«ENDIF»
			fi'''
	}

	// Pour le type "NOP"
	def compile(NOP n) {
		'''nop'''
	}
	
	def compile(FOR_LOOP fl){
		'''
			for «fl.exp.compile» do
				«FOR line : fl.commands»
					«line.compile»
				«ENDFOR»
			od'''
	}
	
	def compile(WHILE w){
		'''
			while «w.cond.compile» do
				«FOR line : w.commands»
					«line.compile»
				«ENDFOR»
			od'''
	}
	
	def compile(FOREACH fe){
		'''
		foreach «fe.exp1.compile» in «fe.exp2.compile» do 
 				«FOR line : fe.commands»
  					«line.compile»
  				«ENDFOR»
  			od'''	
  			}

	//Plus compliqué -> need bcp de modifications au niveau de la grammaire
	def compile(EXPRESSION e){
		'''expression'''
		//TODO
	}

}