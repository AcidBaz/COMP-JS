/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.projet.AFFECT
import org.xtext.example.projet.COMMAND
import org.xtext.example.projet.COMMANDS
import org.xtext.example.projet.DEFINITION
import org.xtext.example.projet.EXPRAND
import org.xtext.example.projet.EXPREQ
import org.xtext.example.projet.EXPRESSION
import org.xtext.example.projet.EXPRNOT
import org.xtext.example.projet.EXPROR
import org.xtext.example.projet.EXPRSIMPLE
import org.xtext.example.projet.FOREACH
import org.xtext.example.projet.FOR_LOOP
import org.xtext.example.projet.FUNCTION
import org.xtext.example.projet.IF_THEN
import org.xtext.example.projet.INPUTS
import org.xtext.example.projet.LEXPR
import org.xtext.example.projet.NOP
import org.xtext.example.projet.OUTPUTS
import org.xtext.example.projet.PROGRAM
import org.xtext.example.projet.WHILE
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ProjetGenerator extends AbstractGenerator {
	
	//table des fonctions
	CodeGenerator gen
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		gen = new CodeGenerator();
		
		// Pour toutes les fonctions du fichier
		/*for (f : resource.allContents.toIterable.filter(typeof(FUNCTION))) {
			// On génère un fichier pour chaque fonction présente dans le fichier
			fsa.generateFile(
				"components/" + f.name + ".whp",
				f.compile	
			)
		}*/

		// Pour le programme entier
		for (d : resource.allContents.toIterable.filter(typeof(PROGRAM))) {
			//generation du code 3@
			gen.generate(d);
			//pretty printer
			fsa.generateFile(
				"file.whp",
				d.compile
			)
		}
	}

	// Pour le type "Domainmodel", qui représente tout le fichier
	def compile(PROGRAM d) {
		// On compile toutes les fonctions comprises dans le fichier une à une
		'''
			«FOR f : d.functions»
				«f.compile»
				
			«ENDFOR»
		'''
	}

	// Pour le type "FUNCTION"
	def compile(FUNCTION f) {
		// On affiche le nom de la fonction, puis on compile le contenu de la fonction
		'''
			function «f.name»:
				«f.def.compile»
		'''
	// f.def.compile est écrit après une tabulation, ce qui va indenter tout le
	// contenu de la fonction
	}

	// Pour le type "DEFINTION"
	def compile(DEFINITION d) {
		// on affiche read input, puis le code intérieur indenté, puis write output
		'''
			read «d.inputs.compile»
			%
				«d.code.compile»
			%
			write «d.outputs.compile»
		'''
	}

	// Pour le type INPUT
	def compile(INPUTS i) {
		// On affiche tous les inputs, séparés par des virgules		
		'''«i.input»«FOR x : i.inputs», «x.compile»«ENDFOR»'''
	}

	// Pour le type OUTPUT
	def compile(OUTPUTS o) {
		//On affiche tous les outputs, séparés par des virgules
		'''«o.output»«FOR x : o.outputs», «x.compile»«ENDFOR»'''
	}

	// Pour le type "COMMANDS"
	def compile(COMMANDS c) {
		// Pour les commandes (IF/NOP/AFFECT/FOR/WHILE/EACH)
		'''
			«c.command.compile»«IF !c.commands.empty» ;«ENDIF»
			«FOR line : c.commands»
				«line.compile»«IF line != c.commands.last» ;«ENDIF»
			«ENDFOR»
		'''
	}

	// Pour le type "COMMAND", càd chaque commande 
	def compile(COMMAND c) {
		// Pour chaque commande, on caste dans le subtype pour le compiler
		if(c.eClass.name == "AFFECT"){
			return '''«(c as AFFECT).compile»'''
		}
		if(c.eClass.name == "IF_THEN"){
			return '''«(c as IF_THEN).compile»'''
		}
		if(c.eClass.name == "NOP"){
			return '''«(c as NOP).compile»'''
		}
		if(c.eClass.name == "FOR_LOOP"){
			return '''«(c as FOR_LOOP).compile»'''
		}
		if(c.eClass.name == "WHILE"){
			return '''«(c as WHILE).compile»'''
		}
		if(c.eClass.name == "FOREACH"){
			return '''«(c as FOREACH).compile»'''
		}
	}

	// Pour le type "AFFECT"
	def compile(AFFECT a) {
		//On écrit toutes les variables de gauche séparées par ", " puis " := ", puis tutes les variables de droites séparées par ", "
		'''«a.variable»«FOR x : a.vars», «x»«ENDFOR» := «a.valeur.compile»«FOR y : a.vals», «y.compile»«ENDFOR»'''
	}

	// Pour le type "IF_THEN"
	def compile(IF_THEN if_then) {
		'''
			if «if_then.cond.compile» then
				«FOR line : if_then.commands1»
					«line.compile»
				«ENDFOR»
			«IF !if_then.commands2.empty»
			else
				«FOR line : if_then.commands2»
					«line.compile»
				«ENDFOR»
			«ENDIF»
			fi'''
	}

	// Pour le type "NOP"
	def compile(NOP n) {
		'''nop'''
	}
	
	//Pour le type "FOR_LOOP"
	def compile(FOR_LOOP fl){
		'''
			for «fl.exp.compile» do
				«FOR line : fl.commands»
					«line.compile»
				«ENDFOR»
			od'''
	}
	
	//Pour le type "WHILE"
	def compile(WHILE w){
		'''
			while «w.cond.compile» do
				«FOR line : w.commands»
					«line.compile»
				«ENDFOR»
			od'''
	}
	
	//Pour le type "FOREACH"
	def compile(FOREACH fe){
		'''
		foreach «fe.exp1.compile» in «fe.exp2.compile» do
			«FOR line : fe.commands»
				«line.compile»
			«ENDFOR»
		od'''	
  	}


	//Pour le type "EXPRESSION"
	def compile(EXPRESSION e){
		'''«e.expand.compile»'''
	}
	
	def compile(EXPRAND e){
		'''«e.expor.compile»«IF !e.expors.empty» and «FOR line:e.expors»«line.compile»«ENDFOR»«ENDIF»'''
	}
	
	def compile(EXPROR e){
		'''«e.expnot.compile»«IF !e.expnots.empty» or «FOR line:e.expnots»«line.compile»«ENDFOR»«ENDIF»'''
	}
	
	def compile(EXPRNOT e){
		if(e.n !== null){
			return '''not «e.expeq.compile»'''
		}else{
			return '''«e.expeq.compile»'''
		}
	}
	
	def compile(EXPREQ e){
		if(e.exp1 !== null){
			return '''«e.exp1.compile»«IF !e.exp2.empty» =? «FOR line:e.exp2»«line.compile»«ENDFOR»«ENDIF»'''
		}else{
			'''(«e.exp.compile»)'''
		}
	}
	
	def compile(EXPRSIMPLE e){
		if(e.nil !== null){
			return '''«e.nil.toString»'''
		}else if(e.variable !== null){
			return '''«e.variable.toString»'''
		}else if(e.symbole !== null){
			return '''«e.symbole.toString»'''
		}else if(e.cons !== null){
			return '''(cons «e.lexpr.compile»)'''
		}else if(e.list !== null){
			return '''(list «e.lexpr.compile»)'''
		}else if(e.hd !== null){
			return '''(hd «e.expr.compile»)'''
		}else if(e.tl !== null){
			return '''(tl «e.expr.compile»)'''
		}else if(e.sym !== null){
			return '''(«e.sym.toString» «e.lexpr.compile»)'''
		}
	}
	
	def compile(LEXPR e){
		'''«e.expr.compile»«IF e.lexpr !== null» «e.lexpr.compile»«ENDIF»'''
	}

}
