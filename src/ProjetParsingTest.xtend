/*
 * generated by Xtext 2.13.0
	LOCATED IN org.xtext.example.projet.tests
 */
package org.xtext.example.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.xtext.example.projet.Domainmodel

@RunWith(XtextRunner)
@InjectWith(ProjetInjectorProvider)
class ProjetParsingTest {
	@Inject
	ParseHelper<Domainmodel> parseHelper
	
	@Test
	def void testSimple01() {
		val result = parseHelper.parse('''
			function truc : 
			read variables entree
			%
			nop
			% 
			write variables sortie
		''')
		Assert.assertNotNull(result)
		val errors = result.eResource.errors
		Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}
	
	
	
	
	@Test
	def void testSimpleWrong01() {
		val result = parseHelper.parse('''
			while cond do set od
			while add kkkkkkk
		''')
		Assert.assertNull(result);
	}
	
	/* ce test ne passera pas avant la définition complète de la grammaire. Il regroupe pas mal de choses poussées
	il nous servira de repère pour savoir quand on aura terminé la grammaire. */
	@Test
	def void testComplexe01() { 
		val result = parseHelper.parse('''
			
			function test :
				read X, Y
				%
					nop
					
					X:=nil;Y:=nil;
					X,Y,Z := Y,Z,nil
					
					if expression_simple 
					then
						X:=expression_simple
					fi
					
					while expression_logique 
					do 
						
					od
					
					if expression_logique
					then	
					 
					else 
					
					fi
					
					for expression_simple 
					do
					
					od
					
					X:=12
				% 
			write X
		''')
		Assert.assertNotNull(result)
		val errors = result.eResource.errors
		Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}
	
	
}
